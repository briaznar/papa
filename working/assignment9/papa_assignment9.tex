% Enable warnings about problematic code
\RequirePackage[l2tabu, orthodox]{nag}


\documentclass{WeSTassignment}
\usepackage{color}

% The lecture title, e.g. "Web Information Retrieval".
\lecture{Introduction to Web Science}
% The names of the lecturer and the instructor(s)
\author{%
  Prof. Dr.~Steffen~Staab\\{\normalsize\mailto{staab@uni-koblenz.de}} \and
  Ren{\'e}~Pickhardt\\{\normalsize\mailto{rpickhardt@uni-koblenz.de}} \and
   Korok~Sengupta\\{\normalsize\mailto{koroksengupta@uni-koblenz.de}} \and 
   Olga~Zagovora\\{\normalsize\mailto{zagovora@uni-koblenz.de}}
}
% Assignment number.
\assignmentnumber{9}
% Institute of lecture.
\institute{%
  Institute of Web Science and Technologies\\%
  Department of Computer Science\\%
  University of Koblenz-Landau%
}
% Date until students should submit their solutions.
\datesubmission{January 18, 2016, 10:00 a.m.}
% Date on which the assignments will be discussed in the tutorial.
\datetutorial{January 20, 2016, 12:00 p.m.}

% Set langauge of text.
\setdefaultlanguage[
  variant = american, % Use American instead of Britsh English.
]{english}

% Specify bib file location.
\addbibresource{bibliography.bib}

% For left aligned centerd boxes
% see http://tex.stackexchange.com/a/25591/75225
\usepackage{varwidth}

% ==============================================================================
% Document

\begin{document}

\maketitle
%Please look at the lessons 1) \textbf{Similarity of Text} \& 2) \textbf{Generative Models}

For all the assignment questions that require you to write scripts, make sure to \textbf{include the scripts in the answer sheet, along with a separate python file.} Where screen shots are required, please add them in the answers directly and not as separate files.\\ \\ 

%Please mention your team Names here: 
Team Name: papa
\\ Team members: 
\\Brigitte Aznar
\\ Bonasmitha Behura
\\ Ilia Tugushi



\section{Generative models (abstract) (10 points)}

In the lecture you will learn about 6 potential parts you could find in research paper
abstracts. Consider the following research paper abstract\footnote{\url {https://www.princeton.edu/~mjs3/salganik_dodds_watts06_full.pdf}}
\blockquote{
\colorbox{orange}{Hit songs, books, and movies are many times more successful than average,} \colorbox{orange}{suggesting that “the best” alternatives are qualitatively different from ``the} \colorbox{orange}{ rest''; yet experts routinely fail to predict which products will succeed.}
\colorbox{green}{We} \colorbox{green}{investigated this paradox experimentally, by creating an artificial ''music market''}
\colorbox{yellow}{in which 14,341 participants downloaded previously unknown songs either with}
\colorbox{yellow}{or without knowledge of previous participants’ choices. Increasing the strength}
\colorbox{yellow}{of social influence increased both inequality and unpredictability of success.} 
\colorbox{pink}{Success was also only partly determined by quality: The best
songs rarely did} \colorbox{pink}{poorly, and the worst rarely did well, but any other result
was possible.}}

\begin{enumerate}
\item Name the 6 potential parts you could find in research paper abstracts.
\item Mark all parts you can find in the given abstract.
\end{enumerate}

\begin{itemize}
\item \textcolor{orange}{State the background and problem}
\item \textcolor{green}{Name the methodology you have used}
\item Formulate 1 to 3 precise research question 
\item \textcolor{yellow}{Talk about your unique solution or idea}
\item \textcolor{pink}{Demonstrate the results}
\item Conclude with a point of impact
\end{itemize}





%-------------------------------------------------------------------------------

\section{Meme spreading model (10 points)}
We provide you with the following excerpt from the meme paper\footnote{ \url {http://www.nature.com/articles/srep00335} } which will be discussed at the lecture. This part of the paper contains and explanation of their basic model. Your task is to \textbf{list five model choices} that stay in conflict with reality and \textbf{discuss the conflict}. 

\blockquote{ Our basic model assumes a frozen network of agents. An agent maintains a
time-ordered list of posts, each about a specific meme. Multiple posts may be
about the same meme. Users pay attention to these memes only. Asynchronously and with uniform probability, each agent can generate a post about a
new meme or forward some of the posts from the list, transmitting the cor-
responding memes to neighboring agents. Neighbors in turn pay attention to
a newly received meme by placing it at the top of their lists. To account for
the empirical observation that past behavior affects what memes the user will
spread in the future, we include a memory mechanism that allows agents to
develop endogenous interests and focus. Finally, we model limited attention
by allowing posts to survive in an agent’s list or memory only for a finite
amount of time. When a post is forgotten, its associated meme become less
represented. A meme is forgotten when the last post carrying that meme
disappears from the user’s list or memory. Note that list and memory work
like first-in-first-out rather than priority queues, as proposed in models of
bursty human activity. In the context of single-agent behavior, our memory
mechanism is reminiscent of the classic Yule-Simon model.


The retweet model we propose is illustrated in Fig. 5. Agents interact on a
directed social network of friends/followers. Each user node is equipped with
a screen where received memes are recorded, and a memory with records of
posted memes. An edge from a friend to a follower indicates that the friend’s
memes can be read on the follower’s screen (\#x and \#y in Fig. 5(a) appear on
the screen in Fig. 5(b)). At each step, an agent is selected randomly to post memes to neighbors. The agent may post about a new meme with probability $p_n$ (\#z in Fig. 5(b)). The posted meme immediately appears at the top of the memory. Otherwise, the agent reads posts about existing memes from the screen. Each post may attract the user’s attention with probability pr (the user pays attention to \#x, \#y in Fig. 5(c)). Then the agent either retweets the post (\#x in Fig. 5(c)) with probability $1 − p_m$, or tweets about a meme chosen from memory (\#v triggered by \#y in Fig. 5(c)) with probability $p_m$. Any post in memory has equal opportunities to be selected, therefore memes that appear more frequently in memory are more likely to be propagated (the memory has two posts about \#v in Fig. 5(d)). To model limited user attention, both screen and memory have a finite capacity, which is the time in which a post remains in an agent’s screen or memory. For all agents, posts are removed after one time unit, which simulates a unit of real time, corresponding to Nu steps where Nu is the number of agents. If people use
the system once weekly on average, the time unit corresponds to a week.}

\begin{enumerate}
\item frozen network of agents
\item limited attention
\item memory mechanism
\item retweet model
\item time model
\end{enumerate}

\begin{enumerate}
\item The paper assumes a frozen network of agents, which means that contrary to reality individual's don't follow or unfollow other users. The network would stay unchanged.
\item It is true that people have limited attention, but it relies on that the memory of users have a limited capacity, which can be true, but as long as the meme keeps propagating, even if it out of a specific user's screen or memory chances are that it comes back by another user.
\item We do agree with the memory mechanism, except maybe that each user might have different memory period, it can't be uniform.
\item The process of retweeting gets propagated to every follower, and not just the neighbor.
\item The time model is representeb by the amount of time agents use the platform, but in real life depends on every user's character and not the frequency of use.
\end{enumerate}
%\subsection{Hints:}
%\begin{enumerate}
%\item  
%\end{enumerate}


%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------

\section{Graph and its properties (10 points)}

Last week we provided you with a graph of out-links\footnote{\url{http://141.26.208.82/store.zip}} of Simple English Wikipedia which should be reused this week. 

Write a function that returns the %radius and 
diameter of the given directed network.
The %radius and 
diameter of a graph is the longest shortest path in the graph. 


\subsection{Hints}
\begin{enumerate}
\item You can first write a function that returns the shortest path between nodes and then find the %radius and
diameter.
\item Do not forget to use proper data structures to avoid a memory shortage.  
\end{enumerate}

\textbf{Answer:}
\\The diameter is 41

\begin{figure}[h!]
  \centering
  \includegraphics{diameter.png}
   \caption{Diameter of the given graph}
     \label{fig:dig} 
\end{figure}

\begin{lstlisting}
import pandas as pd
import networkx as nx
#Functional way, but it takes ages stopped after 6h
def bfs(graph, start, end, visited = []):
    print("{} --- {}".format(start, end))
    # maintain a queue of paths
    queue = []
    if end in visited:
        visited = []
    # push the first path into the queue
    queue.append([start])
    while queue:
        # get the first path from the queue
        path = queue.pop(0)
        # get the last node from the path
        node = path[-1]
        # path found
        if node == end:
            return path
        # enumerate all adjacent nodes, construct a new path and push it into the queue
        for adjacent in graph.get(node, []):
            if adjacent not in visited:
                visited.append(adjacent)
                new_path = list(path)
                new_path.append(adjacent)
                queue.append(new_path)
    return new_path
def diameter(G, df):
    length = 0
    sub_graph = None
    for subgraph in nx.strongly_connected_components(G):
        if len(subgraph) > length:
            sub_graph = subgraph
            length = len(subgraph)

    graph2 = df.ix[list(sub_graph)]['out_links']
    graph2dict = graph2.to_dict()
    G = nx.DiGraph(graph2dict)
    pG = G.subgraph(sub_graph)
    return nx.diameter(pG)
def createDictionary(df):
    graph = {}
    names = []
    for item in df.itertuples():
        graph[item.name] = item.out_links
    return graph
def readStore():
    store = pd.HDFStore('store.h5')
    return store['df2']
def main():
    df = readStore()
    df = df.set_index("name")
    graph = df.to_dict()['out_links']
    G = nx.DiGraph(graph)
    longest_shortest = diameter(G, df)

    #for i in range(0, len(names)):
     #for j in range(0, len(names)):
        #shortest.append(bfs(graph, names[i], names[j]))

    #print(shortest)
    #longest_shortest = max(shortest)
    print("The longest shortest path aka diameter is {}".format(longest_shortest))
if __name__ == "__main__":
        main()

\end{lstlisting}


\makefooter

\end{document}
